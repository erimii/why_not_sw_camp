# -*- coding: utf-8 -*-
"""
Created on Fri Feb  7 09:49:05 2025

@author: Admin
"""

import numpy as np

lst = [2,3,4]
num_array = np.array(lst)
'''
항목item  또는 원소element
배열 내부의 각 요소는 인덱스라고 불리는 정수들로 참조
넘파이에서 차원은 축 axis
(3,) : 형상shape
(4,3,2) -> 3개의 튜플 형식으로 표현되는 3차원 배열 내부의
            각 축이 가지는 최대 원소의 개수
'''

# 다차원 배열의 속성들
num_array.shape
# (3,) : 배열의 형상
num_array.ndim
# 1 -> dim은 dimension의 약자, 배열의 차원
num_array.dtype
# dtype('int32'), 배열의 자료형
num_array.itemsize
# 4 -> 요소의 크기(dtype의 크기)
num_array.size
# 3 -> 요소의 갯수

'''
다차원 배열의 사칙연산
- 사칙연산 수행할 때 개별 원소별로 +,-,*,/ 이루어짐
'''
a=np.array([10,20,30])
b = np.array([1,2,3])
a+b # array([11, 22, 33])

'''
넘파이 배열의 데이터 타입(dtype)을 지정하는 두 가지 방법
-> array(리스트, dtype = 타입)
타입 지정 방법: np.int32 / 'int32'
'''
a = np.array([1,2,3,4], dtype = np.int32)

'''
브로드캐스팅(broadcasting)

벡터화 연산(vectorized operation)
'''
a=np.array([10,20,30])
a*10 # -> array([100, 200, 300])
# 단일 값 : 스칼라

# 2차원 배열과 1차열 배열 연산
b= np.array([[10,20,30],
             [40,50,60]])

c = np.array([2,3,4])
b+c
'''
array([[12, 23, 34],
       [42, 53, 64]])
'''


'''
다차원 배열에 초기값 설정 함수
1. zeros(shape): 모든 값을 0으로
2. ones(shape): 모든 값을 1로
3. full(shape, 값): 모든 값을 지정한 값으로
4. eye(숫자): 숫자만큼 행과열이 만들어짐
'''
zero = np.zeros((2,3))
'''
[[0. 0. 0.]
 [0. 0. 0.]]
'''
one = np.ones((2,3))
'''
[[1. 1. 1.]
 [1. 1. 1.]]
'''
full = np.full((2,3),123)
'''[[123 123 123]
 [123 123 123]]
'''
eye = np.eye(4)
'''
[[1. 0. 0. 0.]
 [0. 1. 0. 0.]
 [0. 0. 1. 0.]
 [0. 0. 0. 1.]]
'''

'''
연속적인 값을 가지는 다차원 배열의 생성
arange(m,n)

arange(m,n,step)

m:시작 값
n: 종료값(-1)
step(간격)
'''
np. arange(0,10)

np.arange(0,10,2)
# array([0, 2, 4, 6, 8])

np.arange(0.1,1.0,0.2)

'''
linspace(start, stop, 구간)
'''
np.linspace(0, 10, 5)
# array([ 0. ,  2.5,  5. ,  7.5, 10. ])

'''
(3, ): 1차원 => [ ]
(1,3) : 2차원 => [ [ ]]
()
'''

'''
다차원 배열의 축과 삽입
insert(어느 배열에, 차원, 데이터)
'''
a=np.array([1,3,4])
np.insert(a, 1,2) 
# array([1, 2, 3, 4])

'''
2차원
insert(어느 배열에, 차원, 데이터, axis=방향)
방향:0행 / 1열
'''
b = np.array([[1,1], [2,2], [3,3]])
np.insert(b, 1, 4, axis = 0)
'''
array([[1, 1],
       [4, 4],
       [2, 2],
       [3, 3]])

axis = 1일 경우
[[1 4 1]
 [2 4 2]
 [3 4 3]]
'''

'''
flip(어느 배열을, axis=방향)
어느 배열을 지정한 방향으로 reverse
'''
c=np.array([[1,2,3],
            [4,5,6]])
np.flip(c, axis=1)
'''
array([[3, 2, 1],
       [6, 5, 4]])
'''

np.flip(c, axis = 0)
'''
array([[4, 5, 6],
       [1, 2, 3]])
'''

'''
insert(), flip() : 원본 데이터에 영향 미치지 않음
파이썬 리스트 연산: 리스트와 리스트 간의 연산
넘파이 다차원 배열 연산: 요소와 요소간의 연산
차원이 다른 넘파이 다차원 배열의 연산 수행시,
자동으로 브로드 캐스팅이 이루어지고
병렬 연산을 함
'''

'''
파이썬의 리스트는 동일하지 않은 자료형
넘파이의 ndarray객체는 동일한 자료형의 항목들만 저장

넘파이는 대용량의 배열과 행렬 연산을 수행
'''

'''
넘파이 배열의 인덱싱과 슬라이싱
다차원 배열 내의 원소는 인덱스라고 불리는 정수를 사용하여 참조
'''
arr_2d = np.array([[1,2,3], 
                   [4,5,6],
                   [7,8,9], 
                   [0,1,2]])
print(arr_2d[0][0])
# 1
print(arr_2d[2])
# [7 8 9]
print(arr_2d[1:][0:2])
'''
[[4 5 6]
 [7 8 9]]
'''

# 최대값, 최소값 출력
a = np.array([10,20,30])
a.max()
a.min()
a.mean()

# 다차원 배열의 타입 변경 : astype()
a.astype(np.float64)

'''
넘파이 다차원 배열의 요소를 1차원으로 변경
flatten()
'''
b = np.array([[1,1],[2,2],[3,3]])
b.flatten()
# array([1, 1, 2, 2, 3, 3])


# 배열의 정렬: sort()
d = np.array([[35,24,55],
              [69,19,9],
              [4,1,11]])
d.sort()
print(d)
'''
[[24 35 55]
 [ 9 19 69]
 [ 1  4 11]]
'''

d.sort(axis=0)
print(d)
'''
[[ 1  4 11]
 [ 9 19 55]
 [24 35 69]]
'''

# append(다차원배열, 다차원배열)
# 첫번째 다차원 배열에 두번째 다차원 배열 추가
# axis =1 
# 축을 명시하지 않으면 기본적으로 1차원으로 만들어짐

a = np.array([1,2,3])
b = np.array([[4,5,6],
             [7,8,9]])
np.append(a,b)
#  array([1, 2, 3, 4, 5, 6, 7, 8, 9])

np.append([a],b,axis=0)
'''
array([[1, 2, 3],
       [4, 5, 6],
       [7, 8, 9]])
'''

# 행렬 곱 : matmul()
a = np.array([[1,2],
              [3,4]])
b = np.array([[10,20],
              [30,40]])
np.matmul(a,b)
'''
array([[ 70, 100],   1*1+2*30  1*20+2*40
       [150, 220]])  3*10+3*40 3*20+4*40
'''

'''
reshape()
차원을 변경시켜주는 함수
'''
sh = np.arange(12)

r = sh.reshape(3,4) # 갯수 맞아야됨
'''
array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11]])
'''

















